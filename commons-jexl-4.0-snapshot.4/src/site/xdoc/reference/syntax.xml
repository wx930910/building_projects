<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>
    <properties>
        <title>Apache Commons JEXL Syntax</title>
    </properties>

    <body>
        <section name="Overview">
            <p>
                This reference is split up into the following sections:
                <ol>
                    <li>
                        <a href="#Language Elements">Language Elements</a>
                    </li>
                    <li>
                        <a href="#Literals">Literals</a>
                    </li>
                    <li>
                        <a href="#Functions">Functions</a>
                    </li>
                    <li>
                        <a href="#Operators">Operators</a>
                    </li>
                    <li>
                        <a href="#Access">Access</a>
                    </li>
                    <li>
                        <a href="#Control">Control Statements</a>
                    </li>
                </ol>
            </p>
            <p>
                For more technical information about the JEXL Grammar, you can find the
                <a href="https://javacc.dev.java.net/">JavaCC</a> grammar for JEXL
                here: <a href="https://gitbox.apache.org/repos/asf?p=commons-jexl.git;a=blob;f=src/main/java/org/apache/commons/jexl3/parser/Parser.jjt">Parser.jjt</a>
            </p>
        </section>
        <section name="Language Elements">
            <table>
                <tr>
                    <th width="15%">Item</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Comments</td>
                    <td>
                        Specified using <code>##</code> or <code>//</code>and extend to the end of line, e.g.
                        <code>## This is a comment</code>
                        Also specified using <code>//</code>, e.g.
                        <code>// This is a comment</code>
                        Multiple lines comments are specified using <code>/*...*/</code>, e.g.
                        <code>/* This is a
                            multi-line comment */</code>
                    </td>
                </tr>
                <tr>
                    <td>Identifiers</td>
                    <td>
                        Must start with <code>a-z</code>, <code>A-Z</code>, <code>_</code> or <code>$</code>.
                        Can then be followed by <code>0-9</code>, <code>a-z</code>, <code>A-Z</code>, <code>_</code> or <code>$</code>.
                        e.g.
                        <ul>
                            <li>Valid: <code>var1</code>,<code>_a99</code>,<code>$1</code></li>
                            <li>Invalid: <code>9v</code>,<code>!a99</code>,<code>1$</code></li>
                        </ul>
                        <p>
                            <strong>N.B.</strong> the following keywords are reserved, and cannot be used as an identifier or the property name when using the dot operator:
                            <code>or and eq ne lt gt le ge in div mod not this null true false instanceof new var final do while break continue remove function return try catch finally throw assert synchronized switch case default byte short int long char boolean float double</code>
                            For example, the following is invalid:
                            <code>my.new.dotted.var1 // invalid ('new' is keyword)</code>
                            In such cases, quoted identifiers or the [ ] operator can be used, for example:
                            <code>my.'new'.dotted.var1</code>
                            <code>my['new'].dotted.var1</code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>Scripts</td>
                    <td>
                        <p>
                            A script in JEXL is made up of zero or more statements, optionally enclosed in a function definition block.
                            One or more pragmas can be specified at the beginning of the script.
                        </p>
                        <p>
                            Scripts can be read from a String, File or URL.
                        </p>
                        <p>
                            Scripts can be created with named parameters which allow a later evaluation to be performed with arguments.
                        </p>
                        <p>
                            By default scripts return the value of the last evaluated statement.
                        </p>
                        <p>
                            Using the <code>return</code> keyword, a script will return the expression that follows (or null).
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>#pragma</td>
                    <td>
                        Declares a pragma, a method to communicate information from a script to its execution environment, e.g.
                        <code>#pragma execution.option 42</code> will declare a pragma named <code>execution.option</code> with
                        a value of <code>42</code>.
                        <p>Pragma keys can be identifiers or antish names, pragma values can be literals (boolean, integer,
                            real, string, null, NaN) and antish names</p>
                    </td>
                </tr>
                <tr>
                    <td>Statements</td>
                    <td>
                        A statement can be the empty statement, the semicolon (<code>;</code>), block, control statement, variable declaration, multiple assignment, or an expression.
                        Statements are optionally terminated with a semicolon.
                        A single statement or a statement block can be annotated.
                    </td>
                </tr>
                <tr>
                    <td>Block</td>
                    <td>
                        A block is simply multiple statements inside curly braces (<code>{, }</code>).
                        <p>The labeled syntax is also supported:
                        <code>foo : {...} </code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> statements.</p>
                    </td>
                </tr>
                <tr>
                    <td>Contextual variables</td>
                    <td>Can be specified outside of the script to create the evaluation context.
                        Contextual variables is of lower precedence in resolution over local variables.
                        <p>Contextual variable names are <strong>case-sensitive</strong>, e.g. <code>var1</code> and <code>Var1</code> are different variables.
                        </p>
                        <p>
                            JEXL supports <code>ant-style</code> contextual variables, the following is a valid variable name:
                            <code>my.dotted.var</code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>Local variables</td>
                    <td>Can be defined untyped by using the <code>var</code> keyword or strongly typed by specifying one of java primitive types:
                        <code>boolean char byte short int long float double</code>
                        The local variable name should be a valid identifier.
                        <ul>
                            <li>Basic declaration: <code>var x;</code></li>
                            <li>Declaration with initialization: <code>var theAnswer = 42;</code> or <code>int theAnswer = 42;</code></li>
                            <li>Invalid declaration: <code>var x.y;</code></li>
                        </ul>
                        Variable scope is either the entire script scope or the function definition block;
                        Local variables take precedence in resolution over contextual variables.
                        The values assigned to the strongly typed variables are implicitly cast to the defined type in non-strict arithmetic mode.
                        Primitive type variables are non-null, so it is impossible to declare a primitive type variable without initialization.
                        When scripts are created with named parameters, those behave as local variables.
                        <p>Variables can be declared as final using <code>final var x = 42</code>,
                           it is required to declare a final variable with initialization.
                        </p>
                        <p>Untyped variables can be declared as non-null using a <code>&amp;</code> declarator before the variable name <code>var &amp;x = 42</code>,
                           it is required to declare a non-null variable with initialization.
                        </p>
                        <p>Variable names are <strong>case-sensitive</strong>, e.g. <code>var1</code> and <code>Var1</code> are different variables.
                        </p>
                        <p>
                            <strong>NOTE:</strong> JEXL does not support variable names with hyphens, e.g.
                            <code>commons-logging // invalid variable name (hyphenated)</code> is not a valid variable, but instead is treated as a
                            subtraction of the variable <code>logging</code> from the variable <code>commons</code>
                        </p>
                        <p>Local variables can not use <code>ant-style</code> naming, only one identifier.</p>
                    </td>
                </tr>
                <tr>
                    <td>Expression</td>
                    <td>
                        An expression can be the literal, variable, assignment, access operator, inline assignment operator, switch operator, iterator operator, stream operator, function definition, function call, method call or
                        an evaluation operator.
                    </td>
                </tr>
                <tr>
                    <td>Assignment</td>
                    <td>
                        Assigns the value to a variable, context variable or property (<code>my.var = 'a value'</code>) using a
                        <code>JexlContext</code> as initial resolver. Both <em>beans</em> and <em>ant-ish</em>
                        variables assignment are supported.
                    </td>
                </tr>
                <tr>
                    <td>Conditional assignment</td>
                    <td>
                        Assigns the value to a variable, context variable or property (<code>my.var ?= 'a value'</code>) if a 
                        variable or a property is null, e.g. 
                        <code>city ?= foo</code> and <code>if (city == null) city = foo</code> are equivalent.
                        Both <em>beans</em> and <em>ant-ish</em> variables assignment are supported.
                    </td>
                </tr>
                <tr>
                    <td>Multiple Assignment</td>
                    <td>
                        Assigns the values to the multiple variables (<code>(x,y) = [4,2]</code>).
                        Assignment can be combined with local variable declaration using the <code>var</code> keyword, e.g.
                        <code>var (x,y) = [4,2]</code> will assign <code>4</code> and <code>2</code> to the variables <code>x</code>
                        and <code>y</code> respectively. Variables can be defined as final using <code>final var (x,y) = [4,2]</code>.
                        The syntax can be used for arrays as well as lists and sets, as well as other expressions that return either of these.
                        <p>If the list of variables assigned to has more variables than values, excess ones are filled with null values.
                        If the list of variables has less variables than values, the extra values are ignored.</p>
                        <p>Multiple assignment can also be used as destructuring assignment when applied to maps and beans, e.g.
                        <code>var (city,street) = {"city":"NY","street":"5th avenue"}</code> will assign <code>NY</code> and <code>5th avenue</code> to
                        the variables <code>city</code> and <code>street</code> respectively. The variable names should match
                        those of bean properties, or map keys, e.g.
                        <code>var (city) = foo</code> and <code>var city = foo.city</code> are equivalent.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>Function definition</td>
                    <td>
                        Defines a function within the script, usually associated with a local variable assignment.
                        <code>var fun = function(x, y) { x + y }</code>
                        Function parameters can be declared by using optional <code>var</code> keyword in parameter declaration list
                        <code>var fun = function(var x, var y) { x + y }</code>
                        A parameter can be defined as final by using <code>final</code> keyword in parameter declaration,
                        in that case the usage of <code>var</code> keyword is mandatory in parameter declaration list
                        <code>var fun = function(final var x, var y) { x + y }</code>
                        A parameter can be defined as required by using <code>&amp;</code> declarator before the parameter name,
                        in that case the usage of <code>var</code> keyword is mandatory in parameter declaration list
                        <code>var fun = function(var &amp;x, var y) { x + y }</code>
                        A parameter can be defined as a strongly typed by specifying one of java primitive types
                        <code>boolean char byte short int long float double</code> instead of <code>var</code> keyword:
                        <code>var fun = function(int x, int y) { x + y }</code>.
                        The actual values passed to the function during invocation will be implicitly cast to the specified parameter types.
                        The following function definition syntax is also supported
                        <code>var fun = (x, y) -> { x + y }</code>
                        If the function body is a simple expression then the following syntax without curly braces can also be used
                        <code>var fun = (x, y) => x + y</code>
                        A function can accept the variable number of arguments, in that case the following syntax can be used
                        <code>var fun = (x, y...) -> {x + y[0] + y[1]}</code>
                        If a function has only one untyped non-final argument and does not accept variable number of arguments
                        then the parentheses around that argument may be omitted
                        <code>var fun = x -> { x * x }</code>
                        <p>Note that functions can also use local variables and parameters from the outer scope they are declared in.
                            The values of those variables are bound to the function context at a definition time and
                            remain unchanged afterwards. Such variables are also considered implicitly final inside the function scope.</p>
                        <code>var t = 20; var s = function(x, y) {x + y + t}; t = 54; s(15, 7)</code>
                        The function closure hoists 't' when defined; the result of the evaluation will
                        lead to <code>15 + 7 + 20 = 42</code>.
                    </td>
                </tr>
                <tr>
                    <td>Function call</td>
                    <td>
                        Calling a function follows the usual convention, e.g.
                        <code>fun(17, 25)</code> will call the <code>fun</code> function with arguments <code>17</code>
                        and <code>25</code>
                        <p>Argument comprehentions syntax can also be used to pass variable number of arguments based on other iterable objects,
                            like collections and arrays, e.g. <code>fun(...[17, 25])</code>
                            will call the <code>fun</code> function with arguments <code>17</code> and <code>25</code></p>
                    </td>
                </tr>
                <tr>
                    <td>Method call</td>
                    <td>
                        Calls a method of an object, e.g.
                        <code>"hello world".hashCode()</code> will call the <code>hashCode</code> method
                        of the <code>"hello world"</code> String.
                        <p>In case of multiple arguments and overloading, JEXL will make the best effort to find
                            the most appropriate non ambiguous method to call.</p>
                    </td>
                </tr>
                <tr>
                    <td>Access Operator</td>
                    <td>
                        <p>Allows to evaluate a property of an object, a value of the collection or an array
                        by using either square brackets or a dotted numeral, e.g.
                        <code>foo.bar</code> will access the <code>bar</code> property
                        of the <code>foo</code> Object.
                        <code>arr1[0]</code> will access the first element of the
                        of the <code>arr1</code> array.</p>
                        <p>Multidimensional array access operator form <code>arr1[x,y]</code> can be used instead of
                        sequential <code>arr1[x][y]</code> form</p>
                        <p>The safe-access operators <code>foo?.bar</code> and <code>foo?[0]</code> shortcuts any null or non-existent references
                        along the navigation path, allowing a safe-navigation free of errors. In the previous expression,
                        if 'foo' is null, the whole expression will evaluate as null. This is an efficient shortcut
                        to defensive expressions such as <code>x?.y?.z</code> that would otherwise be expressed as
                        <code>x? (x.y? (x.y.z ?: null) :null) : null</code>.</p>
                        <p>Properties can also be quoted as in <code>foo.'b a r'</code> and can be dynamic
                        back-quoted interpolation strings as in <code>cal.`${dd.year}-${dd.month}-${dd.day}`</code>.
                        These syntaxes are mixable with safe-access as in <code>foo.'b a r'?.quux</code> or <code>
                            foo?.`${bar}`.quux</code>.</p>
                        <p>Access operators can be overloaded in <code>JexlArithmetic</code>, so that
                           the operator behaviour will differ depending on the type of the operator arguments</p>
                    </td>
                </tr>
                <tr>
                    <td>Inline assignment operator</td>
                    <td>
                        <p>Allows to set a property of an object, a value of the collection or an array
                        by using curly brackets, e.g.
                        <code>foo {bar : 10}</code> will set the <code>bar</code> property
                        of the <code>foo</code> Object to the <code>10</code>.
                        <code>arr1 {[0] : 10}</code> will set the first element of the
                        of the <code>arr1</code> array to the <code>10</code>.</p>
                        <p>Properties can also be quoted as in <code>foo {'b a r' : 10}</code> and can be dynamic
                        back-quoted interpolation strings as in <code>cal {`${dd.year}-${dd.month}-${dd.day}` : '1990-01-01'}</code>.</p>
                        <p>Nested properties can also be assigned as in <code>foo {bar {quux: 10}}</code>.</p>
                        <p>The conditional assignment operator <code>foo {bar ?: 10}</code> can be specified, 
                        which assigns a value to the property only if property is null.</p>
                    </td>
                </tr>
                <tr>
                    <td>Iterator Operator</td>
                    <td>
                        Returns an iterator of iterable object, e.g.
                        <code>...[1,2,3]</code> will return an iterator producing items of the corresponding array.
                        <p>Iterator can also be specified in a form of generator function e.g.
                        <code>...(initValue : x -> {x &lt; 10 ? x + 2 : null})</code>.
                        Generator iterator terminates only when the generator function returns null; If the <code>initValue</code>
                        is null, then the initally empty iterator will be created.</p>
                        <p>The generator function can also take two arguments <code>(index, value) -> {index &lt; 10 ? value + 2 : null}</code>
                        with the first argument <code>index</code> being the zero based index of the next generated element of the sequence,
                        and the second <code>value</code> is the previously generated element.</p>
                    </td>
                </tr>
                <tr>
                    <td>Switch Operator</td>
                    <td>
                        The switch operator evaluates its expression, then returns value of statement block that follow the matching case label, e.g.
                        <code>var x = switch (a) {
                              case 0 -> "zero";
                              case 1 -> "one"
                              default -> "-"
                            } </code>
                        <p>The multilabeled syntax is also supported:
                        <code>var x = switch (a) {
                              case 0, 1 -> "zero";
                              case 2 -> "one"
                              default -> "-"
                            } </code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>Evaluation Operator</td>
                    <td>
                        Performs computational, logical or comparative action between one, two or three arguments
                        whose values are expressions, e.g.
                        <code>40 + 2</code> will call the <code>add</code> operator
                        between two integer literals.
                        <p>All operators, except when stated otherwise, can be overloaded in <code>JexlArithmetic</code>, so that the action taken
                           will differ depending on the type of the operator arguments</p>
                    </td>
                </tr>
                <tr>
                    <td>Stream Operator</td>
                    <td>
                        <p>Stream operators allows to perform transformations of iterable objects into iterators or values.
                        Stream operator can be a projection operator, selection operator or reduction operator</p>
                        <p>Projection operator creates an iterator that produces values specified in the projection.
                        Projection operator can be either an array projection operator <code>a.[foo,bar]</code> or a
                        key-value projection operator <code>a.{foo:bar}</code>.
                        The projection dimensions can be defined either as the properties of the object, <code>a.[foo]</code>
                        or as lambda expressions <code>a.[x - > {x.foo}]</code>.</p>
                        <p>Selection operator creates an iterator that produces only the values that satisfy the specified
                        selection condition <code>a.(x - > {x.foo.length() > 10})</code></p>
                        <p>Reduction operator evaluates a scalar value from iterable object <code>a.$(0 : (x,y) - > {x+y})</code></p>
                    </td>
                </tr>
                <tr>
                    <td>@annotation</td>
                    <td>
                        Annotations in JEXL are 'meta-statements'; they allow to wrap the execution of the JEXL statement in a user provided
                        caller; typical example would be: <code>@lenient x.someMethod();</code>
                        <p>
                            Annotations may be declared with zero or more parameters;
                            <code>@lenient x.someMethod();</code>
                            <code>@parallel(pool, 8) x.someMethod();</code>
                        </p>
                        <p>
                            They also can be chained as in:
                            <code>@lenient @silent x.someMethod();</code>
                        </p>
                        <p>
                        Annotation processing is implemented by providing a JexlContext.AnnotationProcessor; its processAnnotation
                        method will call the annotated statement encapsulated in a Callable. Annotation arguments are evaluated
                        and passed as arguments to processAnnotation.
                        </p>
                    </td>
                </tr>
            </table>
        </section>
        <section name="Literals">
            <table>
                <tr>
                    <th width="15%">Item</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Integer Literals</td>
                    <td>1 or more digits from <code>0</code> to <code>9</code>, eg <code>42</code>.
                    </td>
                </tr>
                <tr>
                    <td>Float Literals</td>
                    <td>
                        1 or more digits from <code>0</code> to <code>9</code>, followed
                        by a decimal point and then one or more digits from
                        <code>0</code> to <code>9</code>,
                        optionally followed by <code>f</code> or <code>F</code>,
                        eg <code>42.0</code> or <code>42.0f</code>.
                    </td>
                </tr>
                <tr>
                    <td>Long Literals</td>
                    <td>1 or more digits from <code>0</code> to <code>9</code> suffixed with <code>l</code> or <code>L</code>
                        , eg <code>42l</code>.
                    </td>
                </tr>
                <tr>
                    <td>Double Literals</td>
                    <td>
                        1 or more digits from <code>0</code> to <code>9</code>, followed
                        by a decimal point and then one or more digits from
                        <code>0</code> to <code>9</code> suffixed with <code>d</code> or <code>D</code>
                        , eg <code>42.0d</code>.
                        A special literal <code>NaN</code> can be used to denote <code>Double.NaN</code> constant
                    </td>
                </tr>
                <tr>
                    <td>BigInteger Literals</td>
                    <td>1 or more digits from <code>0</code> to <code>9</code> suffixed with <code>h</code> or <code>H</code>
                        (for Huge ala OGNL, "does not interfere with hexa-decimal digits"), eg <code>42h</code>.
                    </td>
                </tr>
                <tr>
                    <td>BigDecimal Literals</td>
                    <td>
                        1 or more digits from <code>0</code> to <code>9</code>, followed
                        by a decimal point and then one or more digits from
                        <code>0</code> to <code>9</code> suffixed with <code>b</code> or <code>B</code>)
                        , eg <code>42.0b</code>.
                    </td>
                </tr>
                <tr>
                    <td>Natural literals - binary, octal and hex support</td>
                    <td>
                        Natural numbers (i.e. Integer, Long, BigInteger) can also be expressed as binary, octal or hexadecimal number systems using the same format as Java.
                        i.e. prefix with <code>0b</code> or <code>0B</code> for binary, prefix the number with <code>0</code> for octal,
                        and prefix with <code>0x</code> or <code>0X</code> for hexadecimal.
                        For example <code>0b1000</code>, <code>010</code> or <code>0x10</code>.
                        <p>In natural numbers any number of underscore characters <code>_</code> can appear anywhere between digits</p>
                    </td>
                </tr>
                <tr>
                    <td>Real literals - exponent support</td>
                    <td>
                        Real numbers (i.e. Float, Double, BigDecimal) can also be expressed using standard Java exponent notation.
                        i.e. suffix the number with <code>e</code> or <code>E</code> optionally followed by the sign <code>+</code> or <code>-</code>
                        followed by one or more decimal digits.
                        For example <code>42.0E-1D</code> or <code>42.0E+3B</code>.
                        <p>In real numbers any number of underscore characters <code>_</code> can appear anywhere between digits</p>
                    </td>
                </tr>
                <tr>
                    <td>String literals</td>
                    <td>
                        Can start and end with either <code>'</code> or <code>"</code> delimiters, e.g.
                        <code>"Hello world"</code> and
                        <code>'Hello world'</code> are equivalent.
                        <p>The escape character is <code>\</code> (backslash); it only escapes the string delimiter</p>
                    </td>
                </tr>
                <tr>
                    <td>Multiline format literals</td>
                    <td>
                        Start and end with <code>`</code> delimiter - back-quote -, e.g. <code>`Hello world`</code>
                        <p>The escape character is <code>\</code> (backslash); it only escapes the string delimiter.</p>
                        These format literals can span multiple lines and allow Unified JEXL expressions (JSTL like expressions)
                        to be interpolated. If a variable <code>user</code> valued <code>JEXL</code>is present in the environment - whether
                        as a local or global variable -, the format <code>`Hello ${user}`</code> will evaluate as <code>Hello JEXL</code>.
                    </td>
                </tr>
                <tr>
                    <td>Regular expression (regex) literals</td>
                    <td>
                        Start with <code>~/</code> and ends with <code>/</code> delimiters, e.g.
                        <code>~/ABC.*/</code>
                        <p>The escape character is <code>\</code> (backslash); it only escapes the string delimiter <code>\</code> (slash)</p>
                    </td>
                </tr>
                <tr>
                    <td>Boolean literals</td>
                    <td>
                        The literals <code>true</code> and <code>false</code> can be used, e.g.
                        <code>val1 == true</code>
                    </td>
                </tr>
                <tr>
                    <td>This literal</td>
                    <td>
                        The literal <code>this</code> allows to explicitly access contextual variables in situations when they are covered by local variables
                        or have non-standard names, e.g.
                        <code>this.val1</code>
                        <code>this["var"]</code>
                    </td>
                </tr>
                <tr>
                    <td>Null literal</td>
                    <td>
                        The null value is represented as in java using the literal <code>null</code>, e.g.
                        <code>val1 == null</code>
                    </td>
                </tr>
                <tr>
                    <td>Array literal</td>
                    <td>
                        A <code>[</code> followed by zero or more expressions separated by <code>,</code> and ending
                        with <code>]</code>, e.g.
                        <code>[ 1, 2, "three" ]</code>
                        <p>This syntax creates an <code>Object[]</code>.</p>
                        <p>Empty array literal can be specified as <code>[]</code> with result of creating <code>Object[]</code></p>
                        <p>Array comprehentions syntax can also be used to construct arrays based on other iterable objects,
                            like collections and arrays, e.g.<code>[1, 2, 3, ...[4, 5, 6]]</code></p>
                        <p>
                            JEXL will attempt to strongly type the array; if all entries are of the same class or if all
                            entries are Number instance, the array literal will be an <code>MyClass[]</code> in the former
                            case, a <code>Number[]</code> in the latter case.</p>
                        <p>Furthermore, if all entries in the array literal are of the same class
                            and that class has an equivalent primitive type, the array returned will be a primitive array. e.g.
                            <code>[1, 2, 3]</code> will be interpreted as <code>int[]</code>.</p>
                    </td>
                </tr>
                <tr>
                    <td>List literal</td>
                    <td>
                        A <code>[</code> followed by zero or more expressions separated by <code>,</code> and ending
                        with <code>,...]</code>, e.g.
                        <code>[ 1, 2, "three",...]</code>
                        <p>This syntax creates an <code>ArrayList&lt;Object&gt;</code>.</p>
                        <p>Empty list literal can be specified as <code>[...]</code></p>
                        <p>List comprehentions syntax can also be used to construct lists based on other iterable objects,
                            like collections and arrays, e.g.<code>[1, 2, 3, ...[4, 5, 6],...]</code></p>
                    </td>
                </tr>
                <tr>
                    <td>Immutable List literal</td>
                    <td>
                        A <code>#[</code> followed by zero or more expressions separated by <code>,</code> and ending
                        with <code>]</code>, e.g.
                        <code>#[ 1, 2, "three"]</code>
                        <p>This syntax creates an immutable <code>List&lt;Object&gt;</code>.</p>
                        <p>Empty immutable list literal can be specified as <code>#[]</code></p>
                        <p>List comprehentions can also be used like in conventional List literal syntax</p>
                    </td>
                </tr>
                <tr>
                    <td>Set literal</td>
                    <td>
                        A <code>{</code> followed by zero or more expressions separated by <code>,</code> and ending
                        with <code>}</code>, e.g.
                        <code>{ "one" , 2, "more"}</code>
                        <p>This syntax creates a <code>HashSet&lt;Object&gt;</code>.</p>
                        <p>Empty set literal can be specified as <code>{}</code></p>
                        <p>Set comprehentions syntax can also be used to construct sets based on other iterable objects,
                            like collections and arrays, e.g.<code>{1, 2, 3, ...[4, 5, 6]}</code></p>
                    </td>
                </tr>
                <tr>
                    <td>Immutable Set literal</td>
                    <td>
                        A <code>#{</code> followed by zero or more expressions separated by <code>,</code> and ending
                        with <code>}</code>, e.g.
                        <code>#{ "one" , 2, "more"}</code>
                        <p>This syntax creates an immutable <code>Set&lt;Object&gt;</code>.</p>
                        <p>Empty immutable set literal can be specified as <code>#{}</code></p>
                        <p>Set comprehentions can also be used like in conventional Set literal syntax</p>
                    </td>
                </tr>
                <tr>
                    <td>Map literal</td>
                    <td>
                        A <code>{</code> followed by zero or more sets of <code>key : value</code> pairs separated by <code>,</code> and ending
                        with <code>}</code>, e.g.
                        <code>{ "one" : 1, "two" : 2, "three" : 3, "more": "many more" }</code>
                        <p>This syntax creates a <code>HashMap&lt;Object,Object&gt;</code>.</p>
                        <p>Empty map literal can be specified as <code>{:}</code></p>
                        <p>Map comprehentions syntax can also be used to construct maps based on other maps,
                             e.g.<code>{1:1, 2:2, 3:3, *:...{4:4, 5:5, 6:6}}</code></p>
                    </td>
                </tr>
                <tr>
                    <td>Immutable Map literal</td>
                    <td>
                        A <code>#{</code> followed by zero or more sets of <code>key : value</code> pairs separated by <code>,</code> and ending
                        with <code>}</code>, e.g.
                        <code>#{ "one" : 1, "two" : 2, "three" : 3, "more": "many more" }</code>
                        <p>This syntax creates an immutable <code>Map&lt;Object,Object&gt;</code>.</p>
                        <p>Empty immutable map literal can be specified as <code>#{:}</code></p>
                        <p>Map comprehentions can also be used like in conventional Map literal syntax</p>
                    </td>
                </tr>
                <tr>
                    <td>Map entry literal</td>
                    <td>
                        A <code>[</code> followed by a <code>key : value</code> pair and ending with <code>]</code>, e.g.
                        <code>[ "one" : 1]</code>
                        <p>This syntax creates a <code>Map.Entry&lt;Object,Object&gt;</code>.</p>
                    </td>
                </tr>
                <tr>
                    <td>Range literal</td>
                    <td>
                        A value followed by <code>..</code> and ending with other value, e.g.
                        <code>1 .. 42</code>
                        <p>This syntax creates a 'range' object in the form of a java iterable which can be used in for statement, e.g.
                           <code>for (i : 1..42) a = a + b[i]</code></p>
                    </td>
                </tr>

            </table>
        </section>
        <section name="Functions">
            <table>
                <tr>
                    <th width="15%">Function</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>empty</td>
                    <td>
                        Evaluates whether an expression if 'empty'.
                        This is true when the argument is:
                        <ol>
                            <li>
                                <code>null</code>
                            </li>
                            <li>An instance of class C and the derived JexlArithmetic overloads a method 'public boolean empty(C arg)'
                                that returns true when the argument is considered empty</li>
                            <li>An empty string</li>
                            <li>An array of length zero</li>
                            <li>A collection of size zero</li>
                            <li>An empty map</li>
                            <li>An iterator which 'hasNext()' method returns false</li>
                            <li>Defining a method 'public boolean isEmpty()'
                                that returns true when the instance is considered empty</li>
                        </ol>
                        This is false in other cases (besides errors).
                        <code>empty(arg)</code>
                    </td>
                </tr>
                <tr>
                    <td>size</td>
                    <td>
                        Evaluates the 'size' of an expression.
                        This returns:
                        <ol>
                            <li>0 if the argument is null</li>
                            <li>The result of calling a method from a derived JexlArithmetic overload 'public int size(C arg)',
                                C being the class of the argument</li>
                            <li>Length of an array</li>
                            <li>Length of a string</li>
                            <li>Size of a Collection</li>
                            <li>Size of a Map</li>
                            <li>The result of calling a method 'public int size()' defined by the argument class</li>
                        </ol>
                        This returns 0 in other cases (besides errors).
                        <code>size("Hello")</code> returns 5.
                    </td>
                </tr>
                <tr>
                    <td>new</td>
                    <td>
                        Creates a new instance using a fully-qualified class name or Class:
                        <code>new("java.lang.Double", 10)</code> returns 10.0.
                        <p>Note that the first argument of <code>new</code> can be a variable or any
                            expression evaluating as a String or Class; the rest of the arguments are used
                            as arguments to the constructor for the class considered.</p>
                        <p>In case of multiple constructors, JEXL will make the best effort to find
                            the most appropriate non ambiguous constructor to call.</p>
                    </td>
                </tr>
                <tr>
                    <td>Top level function</td>
                    <td>
                        Top level function is a function which can be invoked without specifying a namespace.
                        <p>Top level function can be defined by the function definition method inside the script</p>
                        <p>A <code>JexlContext</code> can define methods which can be invoked as top level functions.
                        This can allow expressions like:
                        <code>string(23.0)</code></p>
                        <p>Another way to define top level function is to register to <code>JexlEngine</code> objects or classes
                           with null namespace.</p>

                    </td>
                </tr>
                <tr>
                    <td>ns:function</td>
                    <td>
                        A <code>JexlEngine</code> can register objects or classes used as function namespaces.
                        This can allow expressions like:
                        <code>math:cosinus(23.0)</code>
                    </td>
                </tr>
            </table>
        </section>
        <section name="Operators">
            <table>
                <tr>
                    <th width="15%">Operator</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Boolean <code>and</code></td>
                    <td>
                        <p>The usual <code>&amp;&amp;</code> operator can be used as well as the word <code>and</code>, e.g.
                        <code>cond1 and cond2</code> and
                        <code>cond1 &amp;&amp; cond2</code> are equivalent.</p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Boolean <code>or</code></td>
                    <td>
                        <p>The usual <code>||</code> operator can be used as well as the word <code>or</code>, e.g.
                        <code>cond1 or cond2</code> and
                        <code>cond1 || cond2</code> are equivalent.</p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Boolean <code>not</code></td>
                    <td>
                        <p>The usual <code>!</code> operator can be used as well as the word <code>not</code>, e.g.
                        <code>!cond1</code> and
                        <code>not cond1</code> are equivalent.</p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Bitwise <code>and</code></td>
                    <td>
                        The usual <code>&amp;</code> operator is used, e.g.
                        <code>33 &amp; 4</code>, 0010 0001 &amp; 0000 0100 = 0.
                    </td>
                </tr>
                <tr>
                    <td>Bitwise <code>or</code></td>
                    <td>
                        The usual <code>|</code> operator is used, e.g.
                        <code>33 | 4</code>, 0010 0001 | 0000 0100 = 0010 0101 = 37.
                    </td>
                </tr>
                <tr>
                    <td>Bitwise <code>xor</code></td>
                    <td>
                        The usual <code>^</code> operator is used, e.g.
                        <code>33 ^ 4</code>, 0010 0001 ^ 0000 0100 = 0010 0100 = 37.
                    </td>
                </tr>
                <tr>
                    <td>Bitwise <code>complement</code></td>
                    <td>
                        The usual <code>~</code> operator is used, e.g.
                        <code>~33</code>, ~0010 0001 = 1101 1110 = -34.
                    </td>
                </tr>
                <tr>
                    <td>Ternary conditional <code>?:</code> </td>
                    <td>
                        The usual ternary conditional operator <code>condition ? if_true : if_false</code> operator can be
                        used as well as the abbreviation <code>value ? if_true</code> which returns the <code>if_true</code> if
                        its evaluation is defined, non-null and non-false, e.g.
                        <code>val1 ? val2 : null</code> and
                        <code>val1 ? val2 </code> are equivalent.
                        <p>
                            <strong>NOTE:</strong> The condition will evaluate to <code>false</code> when it
                            refers to an undefined variable or <code>null</code> for all <code>JexlEngine</code>
                            flag combinations. This allows explicit syntactic leniency and treats the condition
                            'if undefined or null or false' the same way in all cases.
                        </p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Binary conditional <code>?:</code> </td>
                    <td>
                        The binary conditional operator <code>value ?: if_false</code> returns the <code>value</code> if
                        its evaluation is defined, non-null and non-false, e.g.
                        <code>val1 ?: val2 </code> and
                        <code>val1 ? val1 : val2</code> are equivalent.
                        <p>
                            <strong>NOTE:</strong> The condition will evaluate to <code>false</code> when it
                            refers to an undefined variable or <code>null</code> for all <code>JexlEngine</code>
                            flag combinations. This allows explicit syntactic leniency and treats the condition
                            'if undefined or null or false' the same way in all cases.
                        </p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Null coalescing operator <code>??</code> </td>
                    <td>
                        The null coalescing operator returns the result of its first operand if it is defined and is not null.
                        <p>When <code>x</code>and<code>y</code>are null or undefined,
                            <code>x ?? 'unknown or null x'</code> evaluates as  <code>'unknown or null x'</code>
                            <code>y ?? "default"</code> evaluates as  <code>"default"</code>.
                        </p>
                        <p>
                            When <code>var x = 42</code> and  <code>var y = "forty-two"</code>,<code>x??"other"</code>
                            evaluates as <code>42</code> and <code>y??"other"</code> evaluates as <code>"forty-two"</code>.
                        </p>
                        <p>
                            <strong>NOTE:</strong> this operator does not behave like the ternary conditional since it
                            does not coerce the first argument to a boolean to evaluate the condition.
                            When <code>var x = false</code> and  <code>var y = 0</code>,<code>x??true</code>
                            evaluates as <code>false</code> and <code>y??1</code> evaluates as <code>0</code>.
                        </p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Equality</td>
                    <td>
                        The usual <code>==</code> operator can be used as well as the abbreviation <code>eq</code>.
                        For example
                        <code>val1 == val2</code> and
                        <code>val1 eq val2</code> are equivalent.
                        <ol>
                            <li>
                                <code>null</code> is only ever equal to null, that is if you compare null
                                to any non-null value, the result is false.
                            </li>
                            <li>Equality uses the java <code>equals</code> method</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>Inequality</td>
                    <td>
                        The usual <code>!=</code> operator can be used as well as the abbreviation <code>ne</code>.
                        For example
                        <code>val1 != val2</code> and
                        <code>val1 ne val2</code> are equivalent.
                    </td>
                </tr>
                <tr>
                    <td>In or Match<code>=~</code></td>
                    <td>
                        The syntactically Perl inspired <code>=~</code> operator can be used to check that a <code>string</code> matches
                        a regular expression (expressed either a Java String or a java.util.regex.Pattern).
                        For example
                        <code>"abcdef" =~ "abc.*</code> returns <code>true</code>.
                        It also checks whether any collection, set or map (on keys) contains a value or not; in that case, it behaves
                        as an "in" operator.
                        Note that arrays and user classes exposing a public 'contains' method will allow their instances
                        to behave as right-hand side operands of this operator.
                        <code> "a" =~ ["a","b","c","d","e",f"]</code> returns <code>true</code>.
                    </td>
                </tr>
                <tr>
                    <td>Not-In or Not-Match<code>!~</code></td>
                    <td>
                        The syntactically Perl inspired <code>!~</code> operator can be used to check that a <code>string</code> does not
                        match a regular expression (expressed either a Java String or a java.util.regex.Pattern).
                        For example
                        <code>"abcdef" !~ "abc.*</code> returns <code>false</code>.
                        It also checks whether any collection, set or map (on keys) does not contain a value; in that case, it behaves
                        as "not in" operator.
                        Note that arrays and user classes exposing a public 'contains' method will allow their instances
                        to behave as right-hand side operands of this operator.
                        <code> "a" !~ ["a","b","c","d","e",f"]</code> returns <code>true</code>.
                    </td>
                </tr>
                <tr>
                    <td>Identity</td>
                    <td>
                        The <code>===</code> operator can be used to test that left and right arguments are the same object.
                        For example
                        <code>val1 === val2</code>.
                        <ol>
                            <li>
                                <code>null</code> is considered to be identical only to null, that is if you compare null
                                to any non-null value, the result is false.
                            </li>
                            <li>Identity differs from equality that it does not use the java <code>equals</code> method</li>
                        </ol>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Difference</td>
                    <td>
                        The <code>!==</code> operator can be used to test that left and right arguments are different objects.
                        For example
                        <code>val1 !== val2</code>.
                        This is the reverse of the identity operator.
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Less Than</td>
                    <td>
                        The usual <code>&lt;</code> operator can be used as well as the abbreviation <code>lt</code>.
                        For example
                        <code>val1 &lt; val2</code> and
                        <code>val1 lt val2</code> are equivalent.
                    </td>
                </tr>
                <tr>
                    <td>Less Than Or Equal To</td>
                    <td>
                        The usual <code>&lt;=</code> operator can be used as well as the abbreviation <code>le</code>.
                        For example
                        <code>val1 &lt;= val2</code> and
                        <code>val1 le val2</code> are equivalent.
                    </td>
                </tr>
                <tr>
                    <td>Greater Than</td>
                    <td>
                        The usual <code>&gt;</code> operator can be used as well as the abbreviation <code>gt</code>.
                        For example
                        <code>val1 &gt; val2</code> and
                        <code>val1 gt val2</code> are equivalent.
                    </td>
                </tr>
                <tr>
                    <td>Greater Than Or Equal To</td>
                    <td>
                        The usual <code>&gt;=</code> operator can be used as well as the abbreviation <code>ge</code>.
                        For example
                        <code>val1 &gt;= val2</code> and
                        <code>val1 ge val2</code> are equivalent.
                    </td>
                </tr>
                 <tr>
                    <td>Starts With<code>=^</code></td>
                    <td>
                        The <code>=^</code> operator is a short-hand for the 'startsWith' method.
                        For example, <code> "abcdef" =^ "abc" </code> returns <code>true</code>.
                        Note that through duck-typing, user classes exposing a public 'startsWith' method will allow their instances
                        to behave as left-hand side operands of this operator.
                    </td>
                </tr>
                <tr>
                    <td>Not Starts With<code>!^</code></td>
                    <td>
                        This is the negation of the 'starts with' operator.
                        <code>a !^ "abc"</code> is equivalent to <code>!(a =^ "abc")</code>
                    </td>
                </tr>
                <tr>
                    <td>Ends With<code>=$</code></td>
                    <td>The <code>=$</code> operator is a short-hand for the 'endsWith' method.
                        For example, <code> "abcdef" =$ "def" </code> returns <code>true</code>.
                        Note that through duck-typing, user classes exposing an 'endsWith' method will allow their instances
                        to behave as left-hand side operands of this operator.
                    </td>
                </tr>
                <tr>
                    <td>Not Ends With<code>!$</code></td>
                    <td>
                        This is the negation of the 'ends with' operator.
                        <code>a !$ "abc"</code> is equivalent to <code>!(a =$ "abc")</code>
                    </td>
                </tr>
                <tr>
                    <td>Type comparison <code>instanceof</code></td>
                    <td>
                        The 'instanceof' operator is used to test whether the object is an instance of the specified type (class or subclass or interface).
                        For example <code>"abc" instanceof String</code> returns <code>true</code>.
                        The type name can be either a java primitive type name, a simple name, or a fully qualified name, e.g.
                        <code>"abc" instanceof String</code> and <code>"abc" instanceof java.lang.String</code> are equivalent.
                        A simple class name can be used in the following cases:
                        <ol>
                            <li>for the classes in package java.lang.*</li>
                            <li>for the classes in package java.util.*</li>
                            <li>for the classes in package java.io.*</li>
                            <li>for the classes in package java.net.*</li>
                            <li>for classes without packages</li>
                            <li>for java.math.BigDecimal and java.math.BigInteger classes</li>
                        </ol>
                        The array syntax is also supported, e.g.
                        <code>["abc", "def"] instanceof String[]</code>, or <code>[1,2,3] instanceof int[]</code>.
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Type comparison negation <code>!instanceof</code></td>
                    <td>
                        The '!instanceof' operator is inline variant of negated 'instanceof' operator, e.g.
                        <code>"abc" !instanceof Integer</code> and <code>!("abc" instanceof Integer)</code> are equivalent.
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Type cast <code>()</code></td>
                    <td>
                        The 'cast' operator is used for the conversion of one data type to another.
                        For example <code>(char)42</code> returns <code>'*'</code>.
                        The type name to cast the value to can be any java primitive type name.
                    </td>
                </tr>
                <tr>
                    <td>Object creation<code>new</code></td>
                    <td>
                        Creates a new instance using a class name:
                        <code>new Double(10)</code> returns 10.0.
                        The type name can be either a simple name, or a fully qualified name, e.g.
                        <code>new String("abc")</code> and <code> new java.lang.String("abc")</code> are equivalent.
                        A simple class name can be used in the same cases as specified for the <code>instanceof</code> operator.
                        <p>In case of multiple constructors, JEXL will make the best effort to find
                            the most appropriate non ambiguous constructor to call.</p>
                        <p>The inner class creation syntax is also supported, e.g.
                           <code>outerObject.new InnerClass()</code></p>
                        <p>The array syntax is also supported, e.g.
                           <code>new String[5]</code>, <code>new int[5][7]</code> or <code>new int[5][]</code></p>
                        <p>The array initialization syntax is also supported for single-dimension arrays, e.g.
                           <code>new String[] {'abc','def'}</code></p>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Method reference<code>::</code></td>
                    <td>
                        Creates a method reference using a type/instance and a method name:
                        <code>Double::valueOf</code>
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Left Shift</td>
                    <td>
                        The usual binary signed left shift <code>&lt;&lt;</code> operator is used.
                        For example
                        <code>val1 &lt;&lt; 2</code>
                    </td>
                </tr>
                <tr>
                    <td>Right Shift</td>
                    <td>
                        The usual binary signed right shift <code>&gt;&gt;</code> operator is used.
                        For example
                        <code>val1 &gt;&gt; 2</code>
                    </td>
                </tr>
                <tr>
                    <td>Unsigned Right Shift</td>
                    <td>
                        The usual binary unsigned right shift <code>&gt;&gt;&gt;&gt;</code> operator is used.
                        For example
                        <code>val1 &gt;&gt;&gt; 2</code>
                    </td>
                </tr>
                <tr>
                    <td>Addition</td>
                    <td>
                        The usual <code>+</code> operator is used.
                        For example
                        <code>val1 + val2</code>
                    </td>
                </tr>
                <tr>
                    <td>Subtraction</td>
                    <td>
                        The usual <code>-</code> operator is used.
                        For example
                        <code>val1 - val2</code>
                    </td>
                </tr>
                <tr>
                    <td>Multiplication</td>
                    <td>
                        The usual <code>*</code> operator is used.
                        For example
                        <code>val1 * val2</code>
                    </td>
                </tr>
                <tr>
                    <td>Division</td>
                    <td>
                        The usual <code>/</code> operator is used, or one can use the <code>div</code> operator.
                        For example
                        <code>val1 / val2</code>
                        or
                        <code>val1 div val2</code>
                    </td>
                </tr>
                <tr>
                    <td>Modulus (or remainder)</td>
                    <td>
                        The <code>%</code> operator is used. An alternative is the <code>mod</code>
                        operator.
                        For example
                        <code>5 mod 2</code> gives 1 and is equivalent to <code>5 % 2</code>
                    </td>
                </tr>
                <tr>
                    <td>Block evaluation operator <code>({})</code></td>
                    <td>
                        The block evaluation operator executes a block and returns last evaluated statement as a result.
                        <p>Note that this operator can not be overloaded</p>
                    </td>
                </tr>
                <tr>
                    <td>Side-effect operators</td>
                    <td>
                        Some operators exist in side-effect forms.
                        Their default behavior is to execute the operator and assign the left-hand side with the result.
                        For instance <code>a += 2</code> is equivalent to <code>a = a + 2</code>
                        The list of operators is:
                        <ul>
                            <li>+=</li>
                            <li>-=</li>
                            <li>*=</li>
                            <li>/=</li>
                            <li>%=</li>
                            <li>&amp;=</li>
                            <li>|=</li>
                            <li>^=</li>
                            <li>&lt;&lt;=</li>
                            <li>&gt;&gt;=</li>
                            <li>&gt;&gt;&gt;=</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Increment operator</td>
                    <td>
                        The <code>++</code> operator is used.
                        The default behavior is to increment value and assign the operand with the result.
                        For instance <code>++a</code> is equivalent to <code>a = a + 1</code>
                        operator.
                        <p>The postfix form is also supported: <code>a++</code></p>
                    </td>
                </tr>
                <tr>
                    <td>Decrement operator</td>
                    <td>
                        The <code>--</code> operator is used.
                        The default behavior is to decrement value and assign the operand with the result.
                        For instance <code>--a</code> is equivalent to <code>a = a - 1</code>
                        operator.
                        <p>The postfix form is also supported: <code>a--</code></p>
                    </td>
                </tr>
                <tr>
                    <td>Negate</td>
                    <td>
                        The unary <code>-</code> operator is used. It changes the sign of its numeric argument.
                        For example <code>-12</code> or <code>-(a * b)</code>
                    </td>
                </tr>
                <tr>
                    <td>Positivize</td>
                    <td>
                        The unary <code>+</code> operator is used. It performs an integral promotion meaning
                        that byte, short, char arguments will be promoted to integer as a result.
                        For example  <code>+12</code> or <code>-(a * b)</code>
                    </td>
                </tr>
                <tr>
                    <td>Pointer</td>
                    <td>
                        The unary <code>&amp;</code> operator is used to get a pointer of a variable or a property. e.g.
                        <code>&amp;a</code>
                        Pointer values can be dereferenced via dereference operator, e.g.
                        <code>var x = 1; var y = &amp;x; *y = 2</code>
                    </td>
                </tr>
                <tr>
                    <td>Dereference</td>
                    <td>
                        The unary <code>*</code> operator is used. e.g.
                        <code>*a</code>
                        Note that through duck-typing, user classes exposing a <code>get()</code> method will allow their instances
                        to behave as an operand of this operator.
                        <p>The assignment to a dereferenced object is also supported: <code>*a = 10</code>,
                        any user classes exposing a <code>set(Object)</code> method will allow their instances
                        to accept such assignments.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>Empty</td>
                    <td>
                        The unary <code>empty</code> operator behaves exactly as the corresponding function <code>empty()</code>.
                        For example <code>empty arg</code> and <code>empty(arg)</code> are equivalent
                    </td>
                </tr>
                <tr>
                    <td>Size</td>
                    <td>
                        The unary <code>size</code> operator behaves exactly as the corresponding function <code>size()</code>.
                        For example <code>size [1,2,3]</code> and <code>size([1,2,3])</code> are equivalent
                    </td>
                </tr>
            </table>
        </section>
        <section name="Access">
            <table>
                <tr>
                    <th width="15%">Operator</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Array access</td>
                    <td>
                        Array elements may be accessed using either square brackets or a dotted numeral, e.g.
                        <code>arr1[0]</code> and <code>arr1.0</code> are equivalent
                    </td>
                </tr>
                <tr>
                    <td>List access</td>
                    <td>
                        List elements may be accessed using either square brackets or a dotted numeral, e.g.
                        <code>list[0]</code> and <code>list.0</code> are equivalent
                    </td>
                </tr>
                <tr>
                    <td>Map access</td>
                    <td>
                        Map elements are accessed using square brackets, e.g.
                        <code>map[0]; map['name']; map[var];</code>
                        Note that <code>map['7']</code> and <code>map[7]</code> refer to different elements.
                        Map elements with a numeric key may also be accessed using a dotted numeral, e.g.
                        <code>map[0]</code> and <code>map.0</code> are equivalent.
                        <p>Note that <code>map.1</code> and <code>map.01</code> refer to different elements,
                        while <code>map.1</code> and <code>map[01]</code> are equivalent.</p>
                    </td>
                </tr>
                <tr>
                    <td>JavaBean property access</td>
                    <td>
                        Properties of JavaBean objects that define appropriate getter methods can be accessed
                        using either square brackets or a dotted numeral, e.g.
                        <code>foo['bar']</code> and <code>foo.bar</code> are equivalent.
                        The appropriate <code>Foo.getBar()</code> method will be called.
                        <p>Note that both <code>foo.Bar</code> and <code>foo.bar</code> can be used</p>
                    </td>
                </tr>
                <tr>
                    <td>Indexed JavaBean property access</td>
                    <td>
                        Indexed properties of JavaBean objects that define appropriate getter methods can be accessed
                        using either square brackets or a dotted numeral, e.g.
                        <code>x.attribute['name']</code> and <code>x.attribute.name</code> are equivalent.
                        The appropriate <code>Foo.getAttribute(String index)</code> method will be called
                    </td>
                </tr>
                <tr>
                    <td>Public field access</td>
                    <td>
                        Public fields of java objects can be accessed using either square brackets or a dotted numeral, e.g.
                        <code>foo['bar']</code> and <code>foo.bar</code> are equivalent.
                    </td>
                </tr>
                <tr>
                    <td>Duck-typed collection property access</td>
                    <td>
                        Properties of Java classes that define public <code>Object get(String name)</code> method can be accessed
                        using either square brackets or a dotted numeral, e.g.
                        <code>foo['bar']</code> and <code>foo.bar</code> are equivalent.
                        The appropriate <code>Foo.get(String index)</code> method will be called with the argument of <code>"bar"</code> String
                    </td>
                </tr>
            </table>
        </section>
        <section name="Streams">
            <table>
                <tr>
                    <th width="15%">Operator</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Array projection</td>
                    <td>
                        An array projection operator <code>a.[foo,bar]</code> can define one or more projection dimensions.
                        In case of only one defined dimension <code>a.[foo]</code>, the projection operator creates an iterator
                        that produces a single value. In case of more than one defined dimension <code>a.[foo,bar,quux]</code>,
                        the projection operator creates an iterator that produces an array of the corresponding values.
                    </td>
                    <td>Key-value projection</td>
                    <td>
                        A key-value projection operator <code>a.{foo:bar}</code> creates an iterator
                        that produces <code>Map.Entry</code> object with a key and a value.
                    </td>
                    <td>Selection</td>
                    <td>
                        A selection operator <code>a.(x -> {x.length() > 10})</code> creates an iterator
                        that produces only the objects that satisfy the specified condition.
                        In its basic form the function takes one argument which is the next element of the iterable object.
                        In extended form the function can take two arguments <code>(index,value) -> {index &lt; 10}</code>
                        with the first argument <code>index</code> being the zero based index of the next element of the iterable
                        object, and the second <code>value</code> is the next element itself.
                    </td>
                    <td>Reduction</td>
                    <td>
                        A reduction operator <code>a.@(defaultValue : (result,value) -> {result + value})</code> evaluates
                        the specified function to produce a value from series of values returned by an iterable object.
                        If the iterable object contains no data, the <code>defaultValue</code> will be returned, otherwise
                        the function <code>(result,value) -> {result + value}</code> will be called for each value returned
                        by the iterable object. In its basic form the function takes two arguments, with the first argument
                        <code>result</code> being a partial reduction operator result, and the second argument <code>value</code>
                        being the next element of the iterable object. The function can also take only one argument
                        <code>result -> {result + 1}</code>, or take no arguments at all<code>() -> {nextid()}</code>.
                        In extended form the function can take three arguments <code>(result,index,value) -> {result + value}</code>
                        with additional argument <code>index</code> being the zero based index of the next element of the iterable
                        object.
                        <p>Note that the default value of the reduction operator can be omitted
                           <code>a.@((result,value) -> {result + value})</code>, in that case the default value will be null</p>
                    </td>
                </tr>
            </table>
        </section>
        <section name="Control">
            <table>
                <tr>
                    <th width="15%">Statement</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>if</td>
                    <td>
                        Classic, if/else statement, e.g.
                        <code>if ((x * 2) == 5) {
                            y = 1;
                            } else {
                            y = 2;
                            }</code>
                        <p>The labeled syntax is also supported:
                        <code>foo : if ((x * 2) == 5) {
                            y = 1;
                            } else {
                            y = 2;
                            } </code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> statements.</p>
                    </td>
                </tr>
                <tr>
                    <td>switch</td>
                    <td>
                        The switch statement evaluates its expression, then executes all statements that follow the matching case label, e.g.
                        <code>switch (a) {
                              case 0: return "zero";
                              case 1: return "one"
                              default: return "-"
                            } </code>
                        <p>The labeled syntax is also supported:
                        <code>foo : switch (a) {
                              case 0: return "zero";
                              case 1: return "one"
                              default: return "-"
                            } </code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> statements.</p>
                    </td>
                </tr>
                <tr>
                    <td>for</td>
                    <td>
                        <p>Classic, for(initialization; termination; increment) statement, e.g.
                        <code>for (i = 0; i &lt; 10; i = i + 1) {
                            x = x + item[i];
                            }</code>
                        Where <code>i</code> is a context variable.</p>
                        <p>The following syntax is also supported:
                        <code>for (var i = 0; i &lt; 10; i = i + 1) {
                            x = x + item[i];
                            }</code>

                        Where <code>i</code> is a local variable.</p>
                        <p>The labeled syntax is also supported:
                        <code>foo : for (var i = 0; i &lt; 10; i = i + 1) {
                            x = x + item;
                            } </code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> and <code>continue</code> statements.</p>
                        <p>Note that the loop variable <code>i</code> is accessible after loop evaluation</p>
                    </td>
                </tr>
                <tr>
                    <td>foreach</td>
                    <td>
                        <p>Loop through items of an Array, Collection, Map, Iterator or Enumeration, e.g.
                        <code>for (item : list) {
                            x = x + item;
                            }</code>
                        Where <code>item</code> is a context variable.</p>
                        <p>The following syntax is also supported:
                        <code>for (var item : list) {
                            x = x + item;
                            }</code>

                        Where <code>item</code> is a local variable.</p>
                        <p>The labeled syntax is also supported:
                        <code>foo : for (var item : list) {
                            x = x + item;
                            } </code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code>,<code>continue</code> and <code>remove</code> statements.</p>
                        <p>Note that the loop variable <code>item</code> is accessible after loop evaluation</p>
                        <p>The syntax with a key and a value variable is also supported:
                        <code>for (var i, item : list) {
                            if (i lt 3) x = x + item;
                            }</code>
                        Where <code>i</code> is the index and <code>item</code> is a value variable.
                        For the instances of Map iterator the index variable is the Map key, and the value variable is the Map value</p>
                        <p>The JEXL 1.1 syntax using <code>foreach(item in list)</code> is now <strong>unsupported</strong>.</p>
                    </td>
                </tr>
                <tr>
                    <td>while</td>
                    <td>
                        Loop until a condition is satisfied, e.g.
                        <code>while (x lt 10) {
                            x = x + 2;
                            }</code>
                        <p>The labeled syntax is also supported:
                        <code>foo : while (x lt 10) {
                            x = x + 2;
                            } </code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> and <code>continue</code> statements.</p>
                    </td>
                </tr>
                <tr>
                    <td>do/while</td>
                    <td>
                        Loop until a condition is satisfied, e.g.
                        <code>do {
                            x = x + 2;
                            } while (x lt 10)</code>
                        <p>The labeled syntax is also supported:
                        <code>foo : do {
                            x = x + 2;
                            } while (x lt 10)</code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> and <code>continue</code> statements.</p>
                    </td>
                </tr>
                <tr>
                    <td>continue</td>
                    <td>
                        Within loops (do/while/for), allows to skip to the next iteration.
                        <p>The labeled syntax is also supported:
                        <code>continue foo</code>
                        Where the label <code>foo</code> specifies the loop to which the operation should apply to.</p>
                    </td>
                </tr>
                <tr>
                    <td>remove</td>
                    <td>
                        Within 'for' loops, allows to remove current element from underlying iterator collection and skip to the next iteration.
                        <p>The labeled syntax is also supported:
                        <code>remove foo</code>
                        Where the label <code>foo</code> specifies the loop to which the operation should apply to.</p>
                    </td>
                </tr>
                <tr>
                    <td>break</td>
                    <td>
                        Allows to break from a statement (do/while/for/switch/block) unconditionally.
                        <p>The labeled syntax is also supported:
                        <code>break foo</code>
                        Where the label <code>foo</code> specifies the statement to which the operation should apply to.</p>
                        <p>Note that the unlabeled <code>break</code> statement can not be applied to an unlabeled block</p>
                    </td>
                </tr>
                <tr>
                    <td>return</td>
                    <td>
                        Breaks current script/function execution and returns the value of the specified expression, e.g.
                        <code>return 42</code>
                        If the returned value is not specified, the <code>null</code> will be returned, e.g.
                        <code>
                        return;
                        </code>
                    </td>
                </tr>
                <tr>
                    <td>try/catch/finally</td>
                    <td>
                        Executes a try block and catches the exception, e.g.
                        <code>try {
                              return 42/0;
                            } catch (e) {
                              ...
                            } </code>
                        <p>The following syntax is also supported:
                        <code>try {
                              return 42/0;
                            } catch (var e) {
                              ...
                            } </code>
                        Where <code>e</code> is a local variable.</p>
                        <p>Note that the catch variable <code>e</code> is accessible inside <code>finally</code> block and
                          after the whole statement evaluation</p>
                        <p>Either the <code>catch</code> block, the <code>finally</code> block or both can be specified for the
                        statement</p>
                        <p>The <code>finally</code> block executes always when the try block exits
                        <code>try {
                              return 41;
                            } finally {
                              return 42
                            } </code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>try-with-resources</td>
                    <td>
                        A try statement that declares a resource - the object that must be closed after the statement ends, e.g.
                        <code>try (e = lock()) {
                              return 42/0;
                            } </code>
                        <p>The following syntax is also supported:
                        <code>try (var e = lock()) {
                              return 42/0;
                            } </code>
                        Where <code>e</code> is a local variable.</p>
                        <p>The <code>catch</code> block, the <code>finally</code> block or both can be specified for the
                        statement as described for the <code>try</code> statement</p>
                        <p>Note that the resource variable <code>e</code> is accessible inside the <code>catch</code> or <code>finally</code> block and
                          after the whole statement evaluation</p>
                        <p>The syntax without variable declaration is also supported:
                        <code>try (lock()) {
                              return 42/0;
                            } </code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>throw</td>
                    <td>
                        Throws an exception with the specified text message, e.g.
                        <code>throw "Something wrong here"</code>
                        <p>If the specified argument is the instance of the <code>Throwable</code> class,
                           the provided exception will be rethrown</p>
                    </td>
                </tr>
                <tr>
                    <td>assert</td>
                    <td>
                        An assert is used to declare an expected boolean condition in a script, e.g.
                        <code>assert x == 0</code> or <code>assert x == 0 : "Something wrong here"</code>
                        If the script is evaluated with assertions enabled, then the condition is checked during evaluation.
                        If the condition is false, the assertion error is thrown.
                    </td>
                </tr>
                <tr>
                    <td>synchronized</td>
                    <td>
                        Executes synchronized code, e.g.
                        <code>synchronized (x) {
                            y = x + 2;
                            }</code>
                        <p>The labeled syntax is also supported:
                        <code>foo : synchronized (x) {
                            y = x + 2;
                            }</code>
                        Where the label <code>foo</code> can be used in the inner <code>break</code> statements.</p>
                    </td>
                </tr>
            </table>
        </section>

    </body>
</document>
